package com.karl;

public class test {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// StringBuffer:String缓冲
		// 他开在堆中，本身就是可变的
		// 它的性能高于STRING
		// 它里面封装了一部分方法专门用来做
		// 增:append,insert
		// 删:deleteCharAt,delete
		// 改:setCharAt
		// 查:indexOf,lastIndexOf...
		//
		// String 里的replace（替换）
		// 1、编写方法，将一个字符串中的奇数位上所有的值与偶数位上的值进行交换（利用StringBuffer）
		// StringBuffer bf=new StringBuffer("abcdef");
		// for(int i=0;i<bf.length();i++)
		// {
		// if((i+1)%2==1)
		// {
		// char c=bf.charAt(i);
		// bf.setCharAt(i, bf.charAt(i+1));
		// bf.setCharAt(i+1, c);
		// }
		// }
		// System.out.println(bf.toString());

		// StringBuffer str = new StringBuffer("abcdef");
		// System.out.println(str.toString());
		// System.out.println(str.length()); // str字符串数组长度
		// System.out.println(str.charAt(2)); // str字符串数组下标为2的字符
		// for (int i = 0; i < str.length(); i++) {
		// if ((i+1) % 2 == 1) {
		// char a = str.charAt(i);
		// str.setCharAt(i, str.charAt(i + 1));
		// str.setCharAt(i + 1, a);
		// }
		// }
		// System.out.println(str.toString());

		// 正则表达式
		// 作用就是用来匹配字符串
		//
		// [-]:表示给定一个范围，匹配该范围中的一个字符
		// [^]:表示取反
		// (||)：表示分组
		//
		// {min,max}：表示给定前面字符出现的个数(给定某个区间)
		// +:表示1-N：表示给定前面字符出现的个数(至少要出现一次)
		// *:表示0-N：表示给定前面字符出现的个数(出现与否可以)
		// ?:表示的0-1：表示给定前面字符出现的个数(只能出现0次或者1次)
		//
		// \d:表示[0-9]
		// \w:表示[0-9a-zA-Z]
		// \s:表示匹配一个空格
		// \D:不是数字
		// \W:同上
		// \S:同上
		// .：表示任意一个字符
		//
		//
		// 2 整数或者小数：([0-9]+)|([0-9]+[\\.][0-9]+)
		// 3 只能输入数字：[0-9]+
		// 4 只能输入n位的数字：([0-9]{n})|([0-9]{n}[\\.][0-9]+)
		// 5 只能输入至少n位的数字：([0-9]{n,})|([0-9]{2}[\\.][n,]+)
		// 6 只能输入m~n位的数字：([0-9]{m,n})|([0-9]{2}[\\.][m,n]+)

		// String a = "8192819892";
		// String rel = "[0-9]+";
		// System.out.println(a.matches(rel));

		// 13 只能输入由26个英文字母组成的字符串：([a-z]|[A-Z])+
		// 14 只能输入由26个大写英文字母组成的字符串：[A-Z]+
		// 15 只能输入由26个小写英文字母组成的字符串：[a-z]+
		// 16
		// 只能输入由数字和26个英文字母组成的字符串：([[0-9]+]*[([a-z]|[A-Z])+]+[[0-9]+]+)|([([a-z]|[A-Z])+]*[[0-9]+]+[([a-z]|[A-Z])+]+)
		// 17 只能输入由数字、26个英文字母或者下划线组成的字符串：

		// String a = "_____sdfs";
		// String rel = "([0-9]+)|(([a-z]|[A-Z])+)|([\\_]+)";
		// System.out.println(a.matches(rel));

		// 21 验证Email地址：w{3}[\\.][0-9]{4,}[@]((qq)|(gmail)|(163))[\\.](com)
		// 22 验证InternetURL： www.baidu.com||cn
		// w{3}[\\.][([a-z]|[A-Z])]{4,}[\\.]((cn)|(com)|(top)|(net))
		// 23 验证电话号码：^[1]\\d{10}
		// 24 验证身份证号（15位或18位数字）：\\d{15}|\\d{18}
		// 25 验证一年的12个月：\\d|([1][0-2])
		// 26 验证一个月的31天：([1-2]?\\d)|([3][0-1])

		// String a = "32";
		// String rel = "([1-2]?\\d)|([3][0-1])";
		// System.out.println(a.matches(rel));

		// 27,六位数的密码，数字只能在3-6里选择:[3-6]{6}

		// String a = "345654";
		// String rel = "[3-6]{6}";
		// System.out.println(a.matches(rel));

		// 28、ip地址：
		//
		// IP地址的长度为32位，分为4段，每段8位，用十进制数字表示，每段数字范围为0~255，段与段之间用英文句点“.”隔开。例如：某台计算机IP地址为10.11.44.100。
		//
		// 分析IP地址的组成特点：250-255、200-249、0-199。
		// 这三种情况可以分开考虑，
		// 1. 250-255：特点：三位数，百位是2，十位是5，个位是0~5，用正则表达式可以写成：25[0-5]
		// 2. 200-249：特点：三位数，百位是2，十位是0~4，个位是0~9，用正则表达式可以写成：2[0-4]\d
		// 3. 0-199：这个可以继续分拆，这样写起来更加简单明了.
		// 3.1. 0-9： 特点：一位数，个位是0~9，用正则表达式可以写成：\d
		// 3.2. 10-99： 特点：二位数，十位是1~9，个位是0~9，用正则表达式可以写成：[1-9]\d
		// 3.3. 100-199：特点：三位数，百位是1，十位是0~9，个位是0~9，用正则表达式可以写成：1\d{2}
		//
		// 于是0-99的正则表达式可以合写为[1-9]?\d，那么0-199用正则表达式就可以写成(1\d{2})|([1-9]?\d)，这样0~255的正则表达式就可以写成(25[0-5]|2[0-4]\d|((1\d{2})|([1-9]?\d)))
		// 最后，前面3段加上句点.可以使用{3}重复得到，第4段再来一次同样的匹配，得到IP地址的正则表达式：
		//
		// String regex =
		// "((25[0-5]|2[0-4]\\d|((1\\d{2})|([1-9]?\\d)))\\.){3}(25[0-5]|2[0-4]\\d|((1\\d{2})|([1-9]?\\d)))";
		// String ip = "62.189.123.6";
		// System.out.println(ip.matches(regex));

		// String rels =
		// "(((([1-9]?\\d)|(1\\d{2}))|2[0-4]\\d|25[0-5])\\.){3}((([1-9]?\\d)|(1\\d{2}))|2[0-4]\\d|25[0-5])";
		// String ips = "1.250.22.12";
		// System.out.println(ips.matches(rels));

	}

}
